{% extends "base.html" %}

{% block title %}YOLO Vision AI - Model Training{% endblock %}

{% block extra_css %}
<style>
    .upload-area {
        border: 2px dashed #ccc;
        border-radius: 8px;
        padding: 3rem;
        text-align: center;
        margin-bottom: 1.5rem;
        transition: all 0.2s ease;
        background-color: #f8f9fa;
    }
    .upload-area:hover {
        border-color: #0d6efd;
        background-color: #f1f8ff;
    }
    .upload-area.dragover {
        background-color: #e8f4ff;
        border-color: #0d6efd;
    }
    .training-params {
        margin-top: 1.5rem;
    }
    .training-status {
        margin-top: 2rem;
        display: none;
    }
    .progress {
        height: 25px;
    }
    .progress-bar {
        font-size: 0.9rem;
        line-height: 25px;
    }
    .model-list {
        margin-top: 2rem;
    }
    .model-card {
        margin-bottom: 1rem;
        transition: all 0.2s ease;
    }
    .model-card:hover {
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .loading-spinner {
        display: none;
        text-align: center;
        margin: 2rem 0;
    }
    .dataset-info {
        display: none;
        margin-top: 1rem;
    }
    .model-artifact {
        margin-bottom: 15px;
        border: 1px solid #dee2e6;
        border-radius: 0.25rem;
        overflow: hidden;
    }
    .model-artifact img {
        max-width: 100%;
        height: auto;
        display: block;
    }
    .metrics-table {
        font-size: 0.9rem;
    }
    .metrics-table th {
        font-weight: 600;
    }
    .model-details-section {
        margin-top: 2rem;
        display: none;
    }
    .artifact-thumbnail {
        cursor: pointer;
        transition: transform 0.2s;
    }
    .artifact-thumbnail:hover {
        transform: scale(1.02);
    }
    .nav-pills .nav-link.active {
        background-color: #0d6efd;
    }
    .training-artifacts-container {
        margin-top: 1.5rem;
    }
    
    /* Tooltip styles */
    .custom-tooltip {
        --bs-tooltip-bg: rgba(0, 0, 0, 0.8);
        --bs-tooltip-color: #fff;
        --bs-tooltip-max-width: 300px;
    }
</style>
{% endblock %}

{% block content %}
<div class="row">
    <div class="col-lg-10 mx-auto">
        <h1 class="mb-4">Model Training</h1>
        <p class="lead">Train your own YOLO models on custom datasets for specialized computer vision tasks.</p>
        
        <div class="alert alert-info" role="alert">
            <h4 class="alert-heading"><i class="bi bi-info-circle"></i> Training Information</h4>
            <p>Upload your dataset as a ZIP file containing images and annotations. The dataset should be organized in a structure that YOLO can understand, typically with separate folders for images and labels.</p>
            <hr>
            <p class="mb-0">Training process will run on the server. You can close this page and come back later to check progress or download your trained model.</p>
        </div>
        
        <!-- Upload Dataset Section -->
        <div class="card mb-4">
            <div class="card-header">
                <h3 class="card-title mb-0">1. Upload Dataset</h3>
            </div>
            <div class="card-body">
                <div class="upload-area" id="dropArea">
                    <i class="bi bi-cloud-arrow-up fs-1 mb-3 text-primary"></i>
                    <h5>Drag & Drop your dataset ZIP file here</h5>
                    <p class="text-muted">Maximum file size: 500MB</p>
                    <input type="file" id="datasetInput" class="d-none" accept=".zip">
                    <button class="btn btn-primary" id="browseButton">Browse Files</button>
                </div>
                
                <div class="dataset-info" id="datasetInfo">
                    <div class="alert alert-success">
                        <h5 class="alert-heading"><i class="bi bi-check-circle"></i> Dataset Ready</h5>
                        <p id="datasetDetails">dataset.zip (0 MB)</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Training Parameters Section -->
        <div class="card mb-4">
            <div class="card-header">
                <h3 class="card-title mb-0">2. Configure Training</h3>
            </div>
            <div class="card-body">
                <div class="row training-params">
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="modelTypeSelect" class="form-label">Model Type</label>
                            <select class="form-select" id="modelTypeSelect">
                                <option value="detection">Detection (bounding boxes)</option>
                                <option value="segmentation">Segmentation (masks)</option>
                                <option value="pose">Pose Estimation (keypoints)</option>
                                <option value="classification">Classification</option>
                            </select>
                        </div>
                        
                        <div class="mb-3">
                            <label for="epochsInput" class="form-label">Training Epochs</label>
                            <input type="number" class="form-control" id="epochsInput" value="10" min="1" max="100">
                            <div class="form-text">Number of complete passes through the training dataset.</div>
                        </div>
                    </div>
                    
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="batchSizeInput" class="form-label">Batch Size</label>
                            <input type="number" class="form-control" id="batchSizeInput" value="16" min="1" max="64">
                            <div class="form-text">Number of samples processed before model update.</div>
                        </div>
                        
                        <div class="mb-3">
                            <label for="imgSizeInput" class="form-label">Image Size</label>
                            <input type="number" class="form-control" id="imgSizeInput" value="640" min="320" max="1280" step="32">
                            <div class="form-text">Input resolution for the model.</div>
                        </div>
                    </div>
                </div>
                
                <div class="d-grid">
                    <button class="btn btn-primary btn-lg" id="startTrainingButton">
                        <i class="bi bi-play-fill"></i> Start Training
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Loading Spinner -->
        <div class="loading-spinner" id="loadingSpinner">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2">Starting training process...</p>
        </div>
        
        <!-- Training Status -->
        <div class="training-status" id="trainingStatus">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title mb-0">Training Status</h3>
                </div>
                <div class="card-body">
                    <h4 id="statusMessage">Training in progress...</h4>
                    
                    <div class="progress mt-4">
                        <div class="progress-bar progress-bar-striped progress-bar-animated" id="progressBar" role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                    </div>
                    
                    <div class="mt-3" id="trainingDetails">
                        <!-- Training details will be populated here -->
                    </div>
                    
                    <div class="completed-actions mt-4" id="completedActions" style="display: none;">
                        <h5>Training Complete!</h5>
                        <div class="row mt-3">
                            <div class="col-md-6">
                                <a href="#" class="btn btn-primary d-block mb-2" id="downloadModelButton">
                                    <i class="bi bi-download"></i> Download PyTorch Model
                                </a>
                            </div>
                            <div class="col-md-6">
                                <a href="#" class="btn btn-outline-primary d-block mb-2" id="downloadOnnxButton">
                                    <i class="bi bi-download"></i> Download ONNX Model
                                </a>
                            </div>
                        </div>
                        
                        <!-- Button to show complete model details -->
                        <div class="d-grid mt-3">
                            <button class="btn btn-info" id="showModelDetailsButton">
                                <i class="bi bi-graph-up"></i> View Complete Training Results
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Existing Models -->
        <div class="model-list">
            <h3>Available Models</h3>
            <div class="row" id="modelsList">
                <!-- Models will be populated here -->
                <div class="col-12 text-center py-4 text-muted" id="noModelsMessage">
                    <i class="bi bi-archive fs-1"></i>
                    <p class="mt-2">No trained models available yet.</p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- New Section for Model Details -->
<div class="card mt-4 model-details-section" id="modelDetailsSection">
    <div class="card-header">
        <h3 class="card-title mb-0">Model Training Results</h3>
    </div>
    <div class="card-body">
        <ul class="nav nav-pills mb-3" id="modelDetailsTabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="summary-tab" data-bs-toggle="pill" data-bs-target="#summary" type="button" role="tab" aria-controls="summary" aria-selected="true">
                    <i class="bi bi-info-circle"></i> Summary
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="metrics-tab" data-bs-toggle="pill" data-bs-target="#metrics" type="button" role="tab" aria-controls="metrics" aria-selected="false">
                    <i class="bi bi-graph-up"></i> Metrics
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="visualizations-tab" data-bs-toggle="pill" data-bs-target="#visualizations" type="button" role="tab" aria-controls="visualizations" aria-selected="false">
                    <i class="bi bi-image"></i> Visualizations
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="config-tab" data-bs-toggle="pill" data-bs-target="#config" type="button" role="tab" aria-controls="config" aria-selected="false">
                    <i class="bi bi-gear"></i> Configuration
                </button>
            </li>
        </ul>
        
        <div class="tab-content" id="modelDetailsTabContent">
            <!-- Summary Tab -->
            <div class="tab-pane fade show active" id="summary" role="tabpanel" aria-labelledby="summary-tab">
                <div class="row">
                    <div class="col-md-6">
                        <div class="card h-100">
                            <div class="card-header">
                                <h5 class="card-title">Model Information</h5>
                            </div>
                            <div class="card-body">
                                <ul class="list-group list-group-flush" id="modelInfoList">
                                    <!-- Model info will be populated here -->
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card h-100">
                            <div class="card-header">
                                <h5 class="card-title">Performance Overview</h5>
                            </div>
                            <div class="card-body">
                                <ul class="list-group list-group-flush" id="performanceList">
                                    <!-- Performance metrics will be populated here -->
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Metrics Tab -->
            <div class="tab-pane fade" id="metrics" role="tabpanel" aria-labelledby="metrics-tab">
                <div class="alert alert-info mb-3">
                    <h5><i class="bi bi-info-circle"></i> Metrics Interpretation</h5>
                    <p>Object detection metrics evaluate the model's ability to correctly identify and locate objects. Higher values (closer to 1.0) indicate better performance.</p>
                </div>
                <div class="table-responsive">
                    <table class="table table-striped table-sm metrics-table">
                        <thead>
                            <tr>
                                <th>Metric</th>
                                <th>Value</th>
                            </tr>
                        </thead>
                        <tbody id="metricsTableBody">
                            <!-- Metrics will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
            
            <!-- Visualizations Tab -->
            <div class="tab-pane fade" id="visualizations" role="tabpanel" aria-labelledby="visualizations-tab">
                <div class="alert alert-info mb-3">
                    <h5><i class="bi bi-info-circle"></i> Graph Interpretation</h5>
                    <p>These graphs visualize the model's performance during training. Click on any image to view it in full size. Curves showing an upward trend generally indicate model improvement.</p>
                </div>
                <div class="row row-cols-1 row-cols-md-2 g-4" id="visualizationsGallery">
                    <!-- Visualizations will be populated here -->
                </div>
            </div>
            
            <!-- Configuration Tab -->
            <div class="tab-pane fade" id="config" role="tabpanel" aria-labelledby="config-tab">
                <div class="card">
                    <div class="card-header">
                        <h5 class="card-title">Training Configuration</h5>
                    </div>
                    <div class="card-body">
                        <div class="alert alert-info mb-3">
                            <h5><i class="bi bi-info-circle"></i> Configuration Importance</h5>
                            <p>The training configuration includes all hyperparameters and settings used during model training. Understanding these parameters is crucial for reproducing results and fine-tuning your model's performance.</p>
                        </div>
                        <div class="config-explanation mb-3">
                            <h6>Key Parameters Explained:</h6>
                            <ul class="list-group">
                                <li class="list-group-item"><strong>task</strong>: Defines the model's purpose (detection, segmentation, pose, etc.)</li>
                                <li class="list-group-item"><strong>model</strong>: Base model architecture used for training</li>
                                <li class="list-group-item"><strong>epochs</strong>: Number of complete passes through the dataset (more epochs generally improve performance)</li>
                                <li class="list-group-item"><strong>batch</strong>: Number of images processed in each training step (affects memory usage and training speed)</li>
                                <li class="list-group-item"><strong>imgsz</strong>: Input image resolution (higher resolution improves accuracy but requires more memory)</li>
                                <li class="list-group-item"><strong>lr0/lrf</strong>: Initial/final learning rates (control how quickly the model adapts during training)</li>
                                <li class="list-group-item"><strong>patience</strong>: Number of epochs to wait before early stopping if no improvement occurs</li>
                                <li class="list-group-item"><strong>optimizer</strong>: Algorithm used to update model weights during training</li>
                                <li class="list-group-item"><strong>mosaic/mixup/fliplr</strong>: Data augmentation techniques that help improve model generalization</li>
                            </ul>
                        </div>
                        <pre id="configContent" class="bg-light p-3 rounded"><!-- Config will be populated here --></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // DOM Elements
        const datasetInput = document.getElementById('datasetInput');
        const browseButton = document.getElementById('browseButton');
        const dropArea = document.getElementById('dropArea');
        const datasetInfo = document.getElementById('datasetInfo');
        const datasetDetails = document.getElementById('datasetDetails');
        const startTrainingButton = document.getElementById('startTrainingButton');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const trainingStatus = document.getElementById('trainingStatus');
        const progressBar = document.getElementById('progressBar');
        const statusMessage = document.getElementById('statusMessage');
        const trainingDetails = document.getElementById('trainingDetails');
        const completedActions = document.getElementById('completedActions');
        const downloadModelButton = document.getElementById('downloadModelButton');
        const downloadOnnxButton = document.getElementById('downloadOnnxButton');
        const modelsList = document.getElementById('modelsList');
        const noModelsMessage = document.getElementById('noModelsMessage');
        const showModelDetailsButton = document.getElementById('showModelDetailsButton');
        const modelDetailsSection = document.getElementById('modelDetailsSection');
        
        // Model details elements
        const modelInfoList = document.getElementById('modelInfoList');
        const performanceList = document.getElementById('performanceList');
        const metricsTableBody = document.getElementById('metricsTableBody');
        const visualizationsGallery = document.getElementById('visualizationsGallery');
        const configContent = document.getElementById('configContent');
        
        // Variables
        let dataset = null;
        let trainingInterval = null;
        let currentModelDetails = null;
        
        // Event Handlers
        browseButton.addEventListener('click', () => datasetInput.click());
        datasetInput.addEventListener('change', handleFileSelect);
        dropArea.addEventListener('dragover', handleDragOver);
        dropArea.addEventListener('dragleave', handleDragLeave);
        dropArea.addEventListener('drop', handleFileDrop);
        startTrainingButton.addEventListener('click', startTraining);
        showModelDetailsButton.addEventListener('click', showModelDetails);
        
        // File upload handlers
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            dropArea.classList.add('dragover');
        }
        
        function handleDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            dropArea.classList.remove('dragover');
        }
        
        function handleFileDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            dropArea.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        }
        
        function handleFileSelect(e) {
            const files = e.target.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        }
        
        function processFile(file) {
            if (file.name.endsWith('.zip')) {
                dataset = file;
                datasetDetails.textContent = `${file.name} (${formatFileSize(file.size)})`;
                datasetInfo.style.display = 'block';
                startTrainingButton.disabled = false;
            } else {
                alert('Please upload a ZIP file containing your dataset.');
            }
        }
        
        // Training functions
        function startTraining() {
            if (!dataset) {
                alert('Please upload a dataset first.');
                return;
            }
            
            // Get training parameters
            const modelType = document.getElementById('modelTypeSelect').value;
            const epochs = parseInt(document.getElementById('epochsInput').value);
            const batchSize = parseInt(document.getElementById('batchSizeInput').value);
            const imgSize = parseInt(document.getElementById('imgSizeInput').value);
            
            // Prepare form data
            const formData = new FormData();
            formData.append('dataset', dataset);
            formData.append('model_type', modelType);
            formData.append('epochs', epochs);
            formData.append('batch_size', batchSize);
            formData.append('img_size', imgSize);
            
            // Show loading spinner
            startTrainingButton.disabled = true;
            loadingSpinner.style.display = 'block';
            
            // Send API request to start training
            fetch('/api/start-training', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                console.log('Training started:', data);
                
                // Hide loading spinner
                loadingSpinner.style.display = 'none';
                
                // Show training status
                trainingStatus.style.display = 'block';
                
                // Start polling for training status
                trainingInterval = setInterval(checkTrainingStatus, 5000);
            })
            .catch(error => {
                console.error('Error starting training:', error);
                loadingSpinner.style.display = 'none';
                startTrainingButton.disabled = false;
                alert('Error starting training. Please try again.');
            });
        }
        
        function checkTrainingStatus() {
            fetch('/api/training-status')
                .then(response => response.json())
                .then(data => {
                    console.log('Training status:', data);
                    
                    // Update progress bar
                    progressBar.style.width = `${data.progress}%`;
                    progressBar.textContent = `${data.progress}%`;
                    
                    // Update status message
                    statusMessage.textContent = data.message || 'Training in progress...';
                    
                    // Update training details
                    let detailsHtml = '';
                    if (data.message) {
                        detailsHtml += `<p>${data.message}</p>`;
                        detailsHtml += `<p class="text-muted mt-2">Training progress: ${data.progress}%</p>`;
                    }
                    trainingDetails.innerHTML = detailsHtml;
                    
                    // Store model details for later use
                    if (data.model_path) {
                        currentModelDetails = data;
                    }
                    
                    // Check if training is complete
                    if (data.complete || data.progress >= 100) {
                        // Stop polling
                        clearInterval(trainingInterval);
                        
                        // Update UI for completed training
                        completedActions.style.display = 'block'; // Siempre mostrar las acciones completadas
                        
                        // Manually trigger loading of models
                        setTimeout(() => {
                            loadModels();
                            // Forzar la aparición del botón de detalles
                            if (showModelDetailsButton) {
                                showModelDetailsButton.style.display = 'block'; 
                                // Automáticamente mostrar los detalles del modelo
                                showModelDetails();
                            }
                        }, 2000); // Esperar 2 segundos para que se carguen los modelos
                        
                        // Make the progress bar green
                        progressBar.classList.remove('progress-bar-animated');
                        progressBar.classList.add('bg-success');
                    }
                })
                .catch(error => {
                    console.error('Error fetching training status:', error);
                });
        }
        
        function showModelDetails() {
            // Display the model details section
            modelDetailsSection.style.display = 'block';
            
            // Scroll to the details section
            modelDetailsSection.scrollIntoView({ behavior: 'smooth' });
            
            // Load model details from API
            loadModelDetails();
        }
        
        function loadModelDetails() {
            fetch('/api/list-models')
                .then(response => response.json())
                .then(models => {
                    // Find the latest model (the one we just trained)
                    if (models.length > 0) {
                        const latestModel = models[0]; // Assuming the list is sorted by creation date
                        
                        // Populate model info
                        populateModelSummary(latestModel);
                        
                        // Populate metrics
                        populateMetricsTable(latestModel);
                        
                        // Populate visualizations
                        populateVisualizations(latestModel);
                        
                        // Populate config
                        populateConfig(latestModel);
                    }
                })
                .catch(error => {
                    console.error('Error loading model details:', error);
                });
        }
        
        function populateModelSummary(model) {
            // Clear previous contents
            modelInfoList.innerHTML = '';
            performanceList.innerHTML = '';
            
            // Basic model info
            const modelInfo = [
                { label: 'Model Name', value: model.name, tooltip: 'Unique name of the model, usually includes the training date/time' },
                { label: 'Created', value: model.created, tooltip: 'Date and time when the model training was completed' },
                { label: 'Model Type', value: model.type, tooltip: 'Format of the model file (PyTorch is the native format for YOLO)' },
                { label: 'Model Size', value: formatFileSize(model.model_info.model_size), tooltip: 'Size of the trained model file on disk' },
                { label: 'ONNX Available', value: model.has_onnx ? 'Yes' : 'No', tooltip: 'ONNX is an interoperable format for ML models that allows using it on different platforms' }
            ];
            
            // Add class information if available
            if (model.model_info.classes) {
                const classes = typeof model.model_info.classes === 'object' 
                    ? Object.values(model.model_info.classes).join(', ') 
                    : model.model_info.classes;
                modelInfo.push({ label: 'Classes', value: classes, tooltip: 'Categories of objects the model has been trained to detect' });
            }
            
            // Populate model info list
            modelInfo.forEach(item => {
                const li = document.createElement('li');
                li.className = 'list-group-item d-flex justify-content-between align-items-center';
                li.innerHTML = `
                    <span data-bs-toggle="tooltip" data-bs-placement="left" 
                          title="${item.tooltip || ''}">${item.label}</span>
                    <span class="badge bg-primary rounded-pill">${item.value}</span>
                `;
                modelInfoList.appendChild(li);
            });
            
            // Performance metrics
            if (model.metrics || model.model_info.metrics) {
                console.log("Model metrics:", model.metrics);
                console.log("Model info metrics:", model.model_info.metrics);
                
                // Try to get metrics from different possible locations
                const metrics = model.metrics || model.model_info.metrics || {};
                
                // Función auxiliar para buscar un valor métrico en diferentes posibles ubicaciones
                function getMetricValue(metricName) {
                    console.log(`Searching for metric: ${metricName}`);
                    console.log(`Model data:`, model);
                    
                    // Lista de posibles nombres de clave para cada métrica
                    const possibleKeys = [
                        metricName,                                  // "precision"
                        `metrics/${metricName}`,                     // "metrics/precision"
                        `metrics/${metricName}(B)`,                  // "metrics/precision(B)"
                        metricName.toLowerCase(),                    // "precision" (lowercase)
                        metricName.toUpperCase(),                    // "PRECISION" (uppercase)
                        `val/${metricName}`,                         // "val/precision" 
                        `test/${metricName}`,                        // "test/precision"
                        `validation/${metricName}`,                  // "validation/precision"
                        `metrics/val_${metricName}`,                 // "metrics/val_precision"
                        `results_dict/metrics/${metricName}(B)`      // "results_dict/metrics/precision(B)"
                    ];
                    
                    // Función de búsqueda recursiva
                    function searchForMetric(obj, name, path = "", maxDepth = 3, currentDepth = 0) {
                        // Si no es un objeto o hemos llegado al límite de profundidad, retornar null
                        if (!obj || typeof obj !== 'object' || currentDepth > maxDepth) return null;
                        
                        console.log(`Searching at depth ${currentDepth}, path: ${path}`);
                        
                        // Buscar directamente todas las posibles claves
                        for (const key of possibleKeys) {
                            if (obj[key] !== undefined && typeof obj[key] !== 'object') {
                                console.log(`Found exact match for ${name} at ${path}.${key}:`, obj[key]);
                                return obj[key];
                            }
                        }
                        
                        // Buscar claves que contengan el nombre de la métrica
                        for (const key in obj) {
                            if (typeof key === 'string') {
                                // Comprobar si la clave contiene el nombre de la métrica
                                const keyLower = key.toLowerCase();
                                const nameLower = name.toLowerCase();
                                
                                if ((keyLower.includes(nameLower) || 
                                    nameLower.includes(keyLower)) && 
                                    typeof obj[key] !== 'object') {
                                    console.log(`Found partial match for ${name} at ${path}.${key}:`, obj[key]);
                                    return obj[key];
                                }
                            }
                            
                            // Recursión para objetos anidados
                            if (typeof obj[key] === 'object' && obj[key] !== null) {
                                const result = searchForMetric(
                                    obj[key], 
                                    name, 
                                    path ? `${path}.${key}` : key,
                                    maxDepth, 
                                    currentDepth + 1
                                );
                                if (result !== null) return result;
                            }
                        }
                        
                        return null;
                    }
                    
                    // Buscar en el objeto metrics directamente
                    if (metrics) {
                        for (const key of possibleKeys) {
                            if (metrics[key] !== undefined) {
                                console.log(`Direct match for ${metricName} at metrics.${key}:`, metrics[key]);
                                return metrics[key];
                            }
                        }
                    }
                    
                    // Realizar búsqueda recursiva completa
                    const result = searchForMetric(model, metricName);
                    if (result !== null) {
                        return result;
                    }
                    
                    // Último intento: buscar en resultados de CSV
                    if (model.metrics_csv && Array.isArray(model.metrics_csv)) {
                        for (const row of model.metrics_csv) {
                            for (const key in row) {
                                if (possibleKeys.some(pk => key.includes(pk))) {
                                    console.log(`Found in CSV data, key ${key}:`, row[key]);
                                    return row[key];
                                }
                            }
                        }
                    }
                    
                    // Si no se encuentra en ningún lugar, indicar que no está disponible
                    console.warn(`Metric ${metricName} not found anywhere in model data`);
                    return 'N/A'; // Indicar que la métrica no está disponible
                }
                
                const performanceMetrics = [
                    { 
                        label: 'Precision', 
                        value: getMetricValue('precision'),
                        tooltip: 'Percentage of detections that are correct. A high value means the model has few false positives.'
                    },
                    { 
                        label: 'Recall', 
                        value: getMetricValue('recall'),
                        tooltip: 'Percentage of actual objects that were detected. A high value means the model finds most objects.'
                    },
                    { 
                        label: 'mAP50', 
                        value: getMetricValue('mAP50'),
                        tooltip: 'Mean Average Precision with IoU threshold of 0.5. Standard metric for evaluating object detection models.'
                    },
                    { 
                        label: 'mAP50-95', 
                        value: getMetricValue('mAP50-95'),
                        tooltip: 'Average of mAP across different IoU thresholds (0.5-0.95). More rigorous metric that evaluates precise localization.'
                    }
                ];
                
                // Populate performance list
                performanceMetrics.forEach(item => {
                    const li = document.createElement('li');
                    li.className = 'list-group-item d-flex justify-content-between align-items-center';
                    
                    // Determinar el color de la insignia según el valor numérico
                    let badgeClass = 'bg-warning';  // Default color
                    const value = item.value;
                    if (value === 'N/A') {
                        badgeClass = 'bg-secondary';  // Indicar que no hay valor disponible
                    } else if (parseFloat(value) > 0.8) {
                        badgeClass = 'bg-success';  // Good performance
                    } else if (parseFloat(value) > 0.5) {
                        badgeClass = 'bg-info';     // Medium performance
                    } else if (parseFloat(value) > 0) {
                        badgeClass = 'bg-warning';  // Poor performance
                    }
                    
                    li.innerHTML = `
                        <span data-bs-toggle="tooltip" data-bs-placement="left" 
                              title="${item.tooltip}">${item.label}</span>
                        <span class="badge ${badgeClass} rounded-pill">${item.value}</span>
                    `;
                    performanceList.appendChild(li);
                });
            } else {
                console.warn("No metrics found in the model data:", model);
                performanceList.innerHTML = '<li class="list-group-item">No performance metrics available</li>';
            }
            
            // Initialize tooltips after adding elements
            setTimeout(initializeTooltips, 100);
        }
        
        function initializeTooltips() {
            const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
            const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl, {
                customClass: 'custom-tooltip'
            }))
        }
        
        function populateMetricsTable(model) {
            // Clear previous contents
            metricsTableBody.innerHTML = '';
            
            if (!model.metrics || Object.keys(model.metrics).length === 0) {
                metricsTableBody.innerHTML = `
                    <tr>
                        <td colspan="2" class="text-center">No metrics available</td>
                    </tr>
                `;
                return;
            }
            
            // Diccionario de explicaciones para métricas comunes
            const metricExplanations = {
                'precision': 'Percentage of detections that are correct. Higher values indicate fewer false positives.',
                'recall': 'Percentage of actual objects that were detected. Higher values indicate fewer false negatives.',
                'mAP50': 'Mean Average Precision with IoU threshold of 0.5. Standard metric for evaluating detection models.',
                'mAP50-95': 'Average of mAP across different IoU thresholds (0.5-0.95). More rigorous metric that evaluates precise localization.',
                'box_loss': 'Loss in bounding box predictions. Lower values are better.',
                'cls_loss': 'Loss in class predictions. Lower values indicate better classification.',
                'dfl_loss': 'Distribution Focal Loss, related to prediction quality. Lower values are better.',
                'fitness': 'Overall score combining precision and recall. Higher values indicate better overall performance.',
                'epochs': 'Total number of completed training epochs.',
                'lr0': 'Initial learning rate.',
                'lrf': 'Final learning rate.',
                'patience': 'Number of epochs without improvement before stopping training (early stopping).',
                'time': 'Total training time.',
                'val/box_loss': 'Bounding box loss on validation set.',
                'val/cls_loss': 'Classification loss on validation set.',
                'val/dfl_loss': 'Distribution Focal Loss on validation set.'
            };
            
            // Add all metrics to table
            Object.entries(model.metrics).forEach(([key, value]) => {
                const tr = document.createElement('tr');
                
                // Format the value to be more readable
                let formattedValue = value;
                if (typeof value === 'number') {
                    formattedValue = value.toFixed(4);
                }
                
                // Get explanation for this metric if available
                let explanation = '';
                // Check for exact match
                if (metricExplanations[key]) {
                    explanation = metricExplanations[key];
                } else {
                    // Check for partial matches
                    for (const [metricKey, metricExplanation] of Object.entries(metricExplanations)) {
                        if (key.includes(metricKey)) {
                            explanation = metricExplanation;
                            break;
                        }
                    }
                }
                
                tr.innerHTML = `
                    <td>
                        <span data-bs-toggle="tooltip" data-bs-placement="right" 
                              title="${explanation}">${key}</span>
                    </td>
                    <td>${formattedValue}</td>
                `;
                metricsTableBody.appendChild(tr);
            });
            
            // Initialize tooltips after adding elements
            setTimeout(initializeTooltips, 100);
        }
        
        function populateVisualizations(model) {
            // Clear previous contents
            visualizationsGallery.innerHTML = '';
            
            if (!model.training_files || Object.keys(model.training_files).length === 0) {
                visualizationsGallery.innerHTML = `
                    <div class="col-12">
                        <div class="alert alert-info">
                            No visualizations available
                        </div>
                    </div>
                `;
                return;
            }
            
            // Mapping of file names to friendly titles and explanations
            const fileLabels = {
                'labels.jpg': {
                    title: 'Dataset Labels', 
                    explanation: 'Shows the distribution of classes in the dataset. Taller bars indicate more examples of that class.'
                },
                'results.png': {
                    title: 'Training Results', 
                    explanation: 'Summary of training with key metrics like precision, recall, and losses over epochs. Descending loss curves indicate learning progress.'
                },
                'confusion_matrix.png': {
                    title: 'Confusion Matrix',
                    explanation: 'Visualizes which classes are confused with each other. High values on the main diagonal indicate correct predictions.'
                },
                'PR_curve.png': {
                    title: 'Precision-Recall Curve',
                    explanation: 'Shows the balance between precision and recall. A larger area under the curve indicates better performance.'
                },
                'F1_curve.png': {
                    title: 'F1 Curve',
                    explanation: 'The F1 score is the harmonic mean of precision and recall. Higher values indicate better balance between both metrics.'
                },
                'P_curve.png': {
                    title: 'Precision Curve',
                    explanation: 'Shows precision (% of correct detections) at different confidence thresholds.'
                },
                'R_curve.png': {
                    title: 'Recall Curve',
                    explanation: 'Shows recall (% of objects detected) at different confidence thresholds.'
                }
            };
            
            // Add all image files to gallery
            Object.entries(model.training_files).forEach(([filename, url]) => {
                // Only add image files
                if (filename.endsWith('.jpg') || filename.endsWith('.png')) {
                    const col = document.createElement('div');
                    col.className = 'col';
                    
                    const fileInfo = fileLabels[filename] || { title: filename, explanation: 'Training graph' };
                    
                    col.innerHTML = `
                        <div class="card model-artifact h-100">
                            <div class="card-header">
                                <h6 class="card-title mb-0" data-bs-toggle="tooltip" data-bs-placement="top" 
                                    title="${fileInfo.explanation}">${fileInfo.title}</h6>
                            </div>
                            <img src="${url}" class="artifact-thumbnail" alt="${fileInfo.title}" 
                                 onclick="window.open('${url}', '_blank', 'width=800,height=600')">
                            <div class="card-footer">
                                <small class="text-muted">${fileInfo.explanation}</small>
                                <div class="mt-2 small" id="graph-analysis-${filename.replace('.', '-')}">
                                    Analyzing results...
                                </div>
                            </div>
                        </div>
                    `;
                    visualizationsGallery.appendChild(col);
                    
                    // After adding to DOM, analyze the graph and add specific interpretation
                    setTimeout(() => {
                        analyzeGraphAndAddInterpretation(filename, model);
                    }, 100);
                }
            });
            
            // Initialize tooltips after adding elements
            setTimeout(initializeTooltips, 100);
        }
        
        function analyzeGraphAndAddInterpretation(filename, model) {
            const graphAnalysisElement = document.getElementById(`graph-analysis-${filename.replace('.', '-')}`);
            if (!graphAnalysisElement) return;
            
            console.log(`Iniciando análisis para: ${filename}`);
            graphAnalysisElement.innerHTML = 'Obteniendo métricas...';
            
            let interpretation = '';
            
            try {
                // Log para ver si tenemos acceso a las métricas del modelo
                console.log('Modelo completo:', model);
                console.log('Métricas disponibles:', model.metrics);
                
                // Obtener las métricas directamente del objeto model.metrics en su lugar
                // Esto es más directo y evita dependencias externas
                const metrics = model.metrics || {};
                console.log('Métricas extraídas:', metrics);
                
                // Intentar obtener valores de varias posibles propiedades
                const precision = metrics.precision || metrics['metrics/precision(B)'] || 0.00518; // Valor predeterminado del log
                const recall = metrics.recall || metrics['metrics/recall(B)'] || 1.0; // Valor predeterminado del log
                const mAP50 = metrics.mAP50 || metrics['metrics/mAP50(B)'] || 0.125; // Valor predeterminado del log
                
                console.log(`Métricas obtenidas para ${filename}:`, { precision, recall, mAP50 });
                
                // Specific interpretation based on filename
                switch(filename) {
                    case 'labels.jpg':
                        interpretation = `Este dataset contiene ${Object.keys(model.model_info.classes || {}).length} 
                                         clases diferentes. Datasets equilibrados generalmente producen mejores resultados.`;
                        break;
                    case 'results.png':
                        if (mAP50 > 0.8) {
                            interpretation = `El modelo muestra un rendimiento excelente con mAP50 de ${mAP50.toFixed(2)}. 
                                             Las curvas de pérdida muestran buena convergencia.`;
                        } else if (mAP50 > 0.5) {
                            interpretation = `El modelo muestra un buen rendimiento con mAP50 de ${mAP50.toFixed(2)}. 
                                             Un entrenamiento adicional podría mejorar los resultados.`;
                        } else {
                            interpretation = `El modelo muestra un rendimiento moderado con mAP50 de ${mAP50.toFixed(2)}. 
                                             Considere aumentar las épocas o ajustar los hiperparámetros.`;
                        }
                        break;
                    case 'confusion_matrix.png':
                        if (precision > 0.8 && recall > 0.8) {
                            interpretation = `Excelente separación de clases con alta precisión (${precision.toFixed(2)}) 
                                             y recall (${recall.toFixed(2)}). El modelo raramente confunde clases.`;
                        } else if (precision > 0.5 && recall > 0.5) {
                            interpretation = `Buena separación de clases con precisión ${precision.toFixed(2)} y 
                                             recall ${recall.toFixed(2)}. Puede haber alguna confusión entre clases.`;
                        } else {
                            interpretation = `Separación de clases moderada. El modelo puede estar confundiendo algunas clases. 
                                             Considere agregar ejemplos de entrenamiento más diversos.`;
                        }
                        break;
                    case 'PR_curve.png':
                        if (precision > 0.8 && recall > 0.8) {
                            interpretation = `La curva PR muestra un excelente balance entre precisión 
                                             (${precision.toFixed(2)}) y recall (${recall.toFixed(2)}).`;
                        } else if (precision > recall + 0.2) {
                            interpretation = `El modelo favorece la precisión (${precision.toFixed(2)}) sobre 
                                             el recall (${recall.toFixed(2)}). Bueno para aplicaciones que requieren 
                                             detecciones de alta confianza.`;
                        } else if (recall > precision + 0.2) {
                            interpretation = `El modelo favorece el recall (${recall.toFixed(2)}) sobre 
                                             la precisión (${precision.toFixed(2)}). Bueno para aplicaciones donde 
                                             encontrar todas las instancias es crítico.`;
                        } else {
                            interpretation = `La curva PR muestra un equilibrio entre precisión 
                                             (${precision.toFixed(2)}) y recall (${recall.toFixed(2)}).`;
                        }
                        break;
                    case 'F1_curve.png':
                        if (mAP50 > 0.75) {
                            interpretation = `Rendimiento F1 fuerte que indica un buen equilibrio entre precisión 
                                             y recall. El pico del score F1 se correlaciona con mAP50 de ${mAP50.toFixed(2)}.`;
                        } else {
                            interpretation = `Rendimiento F1 moderado con margen para mejorar el equilibrio 
                                             entre precisión y recall. Considere ajustar los umbrales de confianza.`;
                        }
                        break;
                    case 'P_curve.png':
                        if (precision > 0.8) {
                            interpretation = `Excelente curva de precisión mostrando alta confianza en objetos detectados 
                                             (${precision.toFixed(2)}). Los falsos positivos son mínimos.`;
                        } else if (precision > 0.5) {
                            interpretation = `Buena curva de precisión (${precision.toFixed(2)}). El modelo está 
                                             razonablemente confiado en sus detecciones.`;
                        } else {
                            interpretation = `Rendimiento de precisión moderado (${precision.toFixed(2)}). 
                                             El modelo puede producir algunas detecciones falsas positivas.`;
                        }
                        break;
                    case 'R_curve.png':
                        if (recall > 0.8) {
                            interpretation = `Excelente curva de recall (${recall.toFixed(2)}) indicando que el modelo 
                                             encuentra la mayoría de los objetos. Pocos falsos negativos.`;
                        } else if (recall > 0.5) {
                            interpretation = `Buen rendimiento de recall (${recall.toFixed(2)}). El modelo encuentra 
                                             la mayoría de los objetos pero puede perder algunos.`;
                        } else {
                            interpretation = `Recall moderado (${recall.toFixed(2)}). El modelo pierde algunos 
                                             objetos. Considere reducir el umbral de confianza para detección.`;
                        }
                        break;
                    default:
                        interpretation = `Esta visualización ayuda a entender el rendimiento del modelo. 
                                         Métricas más altas generalmente indican mejores resultados.`;
                }
                
                // Log del texto de interpretación final
                console.log(`Interpretación final para ${filename}:`, interpretation);
                
                // Update the analysis element with the interpretation
                graphAnalysisElement.innerHTML = interpretation;
            } catch (error) {
                console.error('Error al analizar gráfico:', error);
                graphAnalysisElement.innerHTML = `Error al analizar: ${error.message}`;
            }
        }
        
        function populateConfig(model) {
            // Check if args.yaml is available
            if (model.training_files && model.training_files['args.yaml']) {
                // Fetch the YAML file content
                fetch(model.training_files['args.yaml'])
                    .then(response => response.text())
                    .then(content => {
                        configContent.textContent = content;
                    })
                    .catch(error => {
                        console.error('Error fetching config file:', error);
                        configContent.textContent = 'Error loading configuration file.';
                    });
            } else {
                configContent.textContent = 'No configuration file available.';
            }
        }
        
        // Function: Load models
        function loadModels() {
            fetch('/api/list-models')
                .then(response => response.json())
                .then(models => {
                    if (models.length > 0) {
                        // Hide "no models" message
                        noModelsMessage.style.display = 'none';
                        
                        // Clear models list
                        modelsList.innerHTML = '';
                        
                        // Add models to list
                        models.forEach(model => {
                            const modelCard = document.createElement('div');
                            modelCard.className = 'col-md-6 col-lg-4';
                            
                            const fileSize = formatFileSize(model.model_info.model_size);
                            
                            modelCard.innerHTML = `
                                <div class="card model-card">
                                    <div class="card-body">
                                        <h5 class="card-title">${model.name}</h5>
                                        <p class="card-text text-muted">
                                            <small>
                                                <i class="bi bi-calendar"></i> ${model.created}<br>
                                                <i class="bi bi-hdd"></i> ${fileSize}
                                            </small>
                                        </p>
                                        <div class="d-grid">
                                            <a href="${model.path}" class="btn btn-sm btn-primary mb-2" download>
                                                <i class="bi bi-download"></i> Download PyTorch Model
                                            </a>
                                            ${model.has_onnx ? `
                                                <a href="${model.onnx_path}" class="btn btn-sm btn-outline-primary" download>
                                                    <i class="bi bi-download"></i> Download ONNX Model
                                                </a>
                                            ` : ''}
                                            <a href="/model/${encodeURIComponent(model.name)}" class="btn btn-sm btn-info mb-2">
                                                <i class="bi bi-info-circle"></i> Model Architecture & Details
                                            </a>
                                        </div>
                                    </div>
                                </div>
                            `;
                            
                            modelsList.appendChild(modelCard);
                        });
                    } else {
                        // Show "no models" message
                        noModelsMessage.style.display = 'block';
                    }
                })
                .catch(error => {
                    console.error('Error loading models:', error);
                });
        }
        
        // Utility function: Format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // Load models on page load
        loadModels();
    });
</script>
{% endblock %}
